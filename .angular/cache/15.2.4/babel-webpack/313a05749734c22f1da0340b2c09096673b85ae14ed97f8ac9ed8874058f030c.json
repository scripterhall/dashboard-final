{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst util_js_1 = require(\"./util.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = (0, debug_1.default)(\"engine.io-client:transport\"); // debug()\nclass TransportError extends Error {\n  constructor(reason, description, context) {\n    super(reason);\n    this.description = description;\n    this.context = context;\n    this.type = \"TransportError\";\n  }\n}\nclass Transport extends component_emitter_1.Emitter {\n  /**\n   * Transport abstract constructor.\n   *\n   * @param {Object} opts - options\n   * @protected\n   */\n  constructor(opts) {\n    super();\n    this.writable = false;\n    (0, util_js_1.installTimerFunctions)(this, opts);\n    this.opts = opts;\n    this.query = opts.query;\n    this.socket = opts.socket;\n  }\n  /**\n   * Emits an error.\n   *\n   * @param {String} reason\n   * @param description\n   * @param context - the error context\n   * @return {Transport} for chaining\n   * @protected\n   */\n  onError(reason, description, context) {\n    super.emitReserved(\"error\", new TransportError(reason, description, context));\n    return this;\n  }\n  /**\n   * Opens the transport.\n   */\n  open() {\n    this.readyState = \"opening\";\n    this.doOpen();\n    return this;\n  }\n  /**\n   * Closes the transport.\n   */\n  close() {\n    if (this.readyState === \"opening\" || this.readyState === \"open\") {\n      this.doClose();\n      this.onClose();\n    }\n    return this;\n  }\n  /**\n   * Sends multiple packets.\n   *\n   * @param {Array} packets\n   */\n  send(packets) {\n    if (this.readyState === \"open\") {\n      this.write(packets);\n    } else {\n      // this might happen if the transport was silently closed in the beforeunload event handler\n      debug(\"transport is not open, discarding packets\");\n    }\n  }\n  /**\n   * Called upon open\n   *\n   * @protected\n   */\n  onOpen() {\n    this.readyState = \"open\";\n    this.writable = true;\n    super.emitReserved(\"open\");\n  }\n  /**\n   * Called with data.\n   *\n   * @param {String} data\n   * @protected\n   */\n  onData(data) {\n    const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);\n    this.onPacket(packet);\n  }\n  /**\n   * Called with a decoded packet.\n   *\n   * @protected\n   */\n  onPacket(packet) {\n    super.emitReserved(\"packet\", packet);\n  }\n  /**\n   * Called upon close.\n   *\n   * @protected\n   */\n  onClose(details) {\n    this.readyState = \"closed\";\n    super.emitReserved(\"close\", details);\n  }\n  /**\n   * Pauses the transport, in order not to lose packets during an upgrade.\n   *\n   * @param onPause\n   */\n  pause(onPause) {}\n}\nexports.Transport = Transport;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}